---
title: "에디터"
date: 2026-02-22
category: 정렬
difficulty: medium
tags:
  - 에디터
---

# 에디터

| 항목 | 내용 |
|------|------|
| 📅 작성일 | 2026-02-22 |
| 📁 카테고리 | 정렬 |
| 🎯 난이도 | 🟡 보통 |
| ⏱️ 시간 복잡도 | **O(n)** |
| 💾 공간 복잡도 | **O(n)** |
| 🏷️ 태그 | `에디터` |

## 📝 개요

에디터 성공다국어
시간 제한	메모리 제한	제출	정답	맞힌 사람	정답 비율
0.3 초 (하단 참고)	512 MB	154435	45498	30577	27.990%
문제
한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.

이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.

이 편집기가 지원하는 명령어는 다음과 같다.

L	커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)
D	커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)
B	커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)
삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임
P $	$라는 문자를 커서 왼쪽에 추가함
초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.

입력
첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.

출력
첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.

예제 입력 1 
abcd
3
P x
L
P y
예제 출력 1 
abcdyx
예제 입력 2 
abc
9
L
L
L
L
L
P x
L
B
P y
예제 출력 2 
yxabc
예제 입력 3 
dmih
11
B
B
P x
L
B
B
B
P y
D
D
P z
예제 출력 3 
yxz

## 💻 알고리즘 코드

```javascript
// 백준 스타일 입력 — require("fs").readFileSync 지원
const input = require("fs").readFileSync("/dev/stdin", "utf8").trim();
const [str,n,...inputsStr] = input.split("\n");
const strArr = str.split("")
const inputs = inputsStr.map((s)=>s.split(" "))


class Node {
  constructor(data) {
    this.data = data; // 데이터 저장
    this.next = null; // 다음 노드를 가리키는 화살표
  }
}

class LinkedList {
 constructor() {
    this.head = new Node(null); // 더미 헤드 (구현 편의상)
    this.cursor = this.head;    // 현재 커서가 가리키는 노드
  }

  moveL() {
    if (this.cursor.prev) this.cursor = this.cursor.prev;
  }

  moveD() {
    if (this.cursor.next) this.cursor = this.cursor.next;
  }

  deleteBack() {
    if (this.cursor === this.head) return;
    const prevNode = this.cursor.prev;
    const nextNode = this.cursor.next;

    prevNode.next = nextNode;
    if (nextNode) nextNode.prev = prevNode;
    
    this.cursor = prevNode; // 삭제 후 커서 위치 조정
  }

  appendPointer(data) {
    const newNode = new Node(data);
    const nextNode = this.cursor.next;

    newNode.prev = this.cursor;
    newNode.next = nextNode;

    this.cursor.next = newNode;
    if (nextNode) nextNode.prev = newNode;

    this.cursor = newNode; // 추가 후 커서 위치 조정
  }
  
  getList() {
      const results = []
    let cur = this.head
      while(cur){
          results.push(cur.data)
          cur = cur.next
      }
      
      return results
  }
}


function solution(strArr, inputs){
  const linkedList = new LinkedList()

  strArr.forEach((str)=> linkedList.appendPointer(str))

   inputs.forEach((input)=>{
     const [command, data ]= input
     switch(true){
       case "L" === command :
         linkedList.moveL()
         break
         
          case "D" === command :
         linkedList.moveD()
         break

       case command === "B" :
         linkedList.deleteBack()
         break
        
         case command === "P":
             
         linkedList.appendPointer(data)
        
         break

       default: 
         console.log("there is not command")
     }
   })

   return linkedList.getList().join("")
}
console.log(solution(strArr, inputs))
```

## 📥 입력과 출력

### 입력

```
abcd
3
P x
L
P y
```

### 출력

```
undefined
```

## 📊 복잡도 분석

| 구분 | 복잡도 |
|------|--------|
| ⏱️ 시간 복잡도 | **O(n)** |
| 💾 공간 복잡도 | **O(n)** |

> 반복문 1개, 빌트인 메서드 7개 감지. 시간 복잡도 O(n)(선형 시간 — 입력에 비례), 공간 복잡도 O(n).

#### 상세 분석

- 📦 **Line 3** `input.split("\n")` — String.split()는 O(n)
- 📦 **Line 4** `str.split("")` — String.split()는 O(n)
- 📦 **Line 5** `inputsStr.map((s)=>s.split(" "))` — Array.map()는 O(n)
- 📦 **Line 5** `s.split(" ")` — String.split()는 O(n)
- 🔄 **Line 56** `while(cur){` — 반복문 중첩 깊이 1 → O(n)
- 📦 **Line 69** `strArr.forEach((str)=> linkedList.appendPointer(st…` — Array.forEach()는 O(n)
- 📦 **Line 71** `inputs.forEach((input)=>{` — Array.forEach()는 O(n)
- 📦 **Line 97** `linkedList.getList().join("")` — Array.join()는 O(n)

## 🔍 실행 흐름 분석

총 **22개**의 실행 단계가 기록되었습니다.

| Step | Line | input | str | n | inputsStr | strArr | inputs | solution | linkedList | command | data | 설명 |
|------|------|------|------|------|------|------|------|------|------|------|------|------|
| 1 | 2 | "abcd
3
P x
L
P y" | - | - | - | - | - | - | - | - | - | const input = "abcd
3
P x
L
P y" |
| 2 | 3 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | - | - | - | - | - | - | const destructured = ["abcd", "3", "P x", "L", "P y"] |
| 3 | 4 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | - | - | - | - | - | const strArr = ["a", "b", "c", "d"] |
| 4 | 5 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | - | - | - | - | const inputs = [["P", "x"], ["L"], ["P", "y"]] |
| 5 | 66 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | - | - | - | function solution() declared |
| 6 | 67 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | - | - | const linkedList = undefined |
| 7 | 69 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | - | - | strArr.forEach((str)=> linkedList.appendPointer(str))() called |
| 8 | 72 | ["P", "x"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "x" | const destructured = ["P", "x"] |
| 9 | 73 | ["P", "x"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "x" | switch (true) |
| 10 | 88 | ["P", "x"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "x" | linkedList.appendPointer(data)() called |
| 11 | 90 | ["P", "x"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "x" | break |
| 12 | 72 | ["L"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "L" | undefined | const destructured = ["L"] |
| 13 | 73 | ["L"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "L" | undefined | switch (true) |
| 14 | 75 | ["L"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "L" | undefined | linkedList.moveL()() called |
| 15 | 76 | ["L"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "L" | undefined | break |
| 16 | 72 | ["P", "y"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "y" | const destructured = ["P", "y"] |
| 17 | 73 | ["P", "y"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "y" | switch (true) |
| 18 | 88 | ["P", "y"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "y" | linkedList.appendPointer(data)() called |
| 19 | 90 | ["P", "y"] | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | "P" | "y" | break |
| 20 | 71 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | - | - | inputs.forEach((input)=>{() called |
| 21 | 97 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | undefined | - | - | return undefined |
| 22 | 99 | "abcd
3
P x
L
P y" | "abcd" | "3" | ["P x", "L", "P y"] | ["a", "b", "c", "d"] | [["P", "x"], ["L"], ["P", "y"]] | [Function] | - | - | - | console.log(solution(strArr, inputs))() called |

## 💡 핵심 포인트

반복문이 있으면 시간초과가 뜸

해당 위치에 값을 갖고오는 조건이 없기때문에 현재 위치의 노드를 저장(cursor)
이후 커먼드에 따라 현재 위치 노드를 변경

---

> 🤖 이 포스트는 **Algorithm Flow** 시각화 도구를 통해 자동으로 생성되었습니다.
> 📅 생성 일시: 2026. 2. 22. 오후 2:03:30
